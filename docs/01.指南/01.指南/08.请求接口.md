---
title: 接口
date: 2021-11-17
permalink: /pages/9a083a/
article: false
---

## 准备

怎么开始封装一个`axios`呢，两样东西就够了。（也许你会说`http`、`ajax`或者`axios`源码，那可能就脱离主题了）

- [axios 官方文档](http://www.axios-js.com/zh-cn/)：除了在这里了解`axios`，更重要的是如何使用它的配置项、api
- 案例：简洁版（了解基本原理和使用）=》进化版（功能的逐步完善）=》高阶版（模块与封装）

## 接口使用

前端应用向后端接口请求数据的核心。这里的 types 文件可以自行抽离出去，放到项目根目录下的 types 文件夹中

![image-20211201155753348](https://gitee.com/huohuomua/pictures/raw/master/202112011557475.png)

http 文件夹最后返回一个 API `http`，通过这个 API，所有的接口请求都封装在 src/api 下（模块化）进行管理，如动态路由：

```typescript
import { http } from "../utils/http";

export const getAsyncRoutes = (data?: object) => {
  return http.request("get", "/getAsyncRoutes", data);
};
```

## 封装

### axios 类

```js
class EnclosureHttp {
	constructor() {},
	private ...
	public ...
}

export default EnclosureHttp;
```

### axios 配置

实例化 axios 的时候，我们可以传入自定义的配置项，根据不同情况下的需要，动态地控制 axios 请求（比如不同环境下不同的请求地址）。

```typescript
// src/utils/http/core.ts
import Axios, { AxiosInstance } from "axios";
import { genConfig } from "./config";

class EnclosureHttp {
  private static axiosInstance: AxiosInstance = Axios.create(genConfig()); // 创建并保存当前Axios实例对象
}
```

```typescript
// src/utils/http/config.ts
import { AxiosRequestConfig } from "axios";
import { excludeProps } from "./utils";
// 设定一个默认配置
export const defaultConfig: AxiosRequestConfig = {
  baseURL: "", // 基础请求地址
  timeout: 10000, // 10秒超时
  headers: {
    // 发送的自定义请求头
    Accept: "application/json, text/plain, */*",
    "Content-Type": "application/json",
    "X-Requested-With": "XMLHttpRequest",
  },
};

export function genConfig(config?: AxiosRequestConfig): AxiosRequestConfig {
  if (!config) {
    return defaultConfig;
  }
  const { headers } = config;
  if (headers && typeof headers === "object") {
    defaultConfig.headers = {
      ...defaultConfig.headers,
      ...headers,
    };
  }
  return { ...excludeProps(config!, "headers"), ...defaultConfig };
}
```

### get 和 post

在说`request`之前，我们先看`get`和`post`，这是为了理清`request`接收的是什么样的参数。

```typescript
  public post<T>(
    url: string,
    params?: T,
    config?: EnclosureHttpRequestConfig
  ): Promise<T> {
    return this.request<T>("post", url, params, config); // 接收四个参数
  }

  public get<T>(
    url: string,
    params?: T,
    config?: EnclosureHttpRequestConfig
  ): Promise<T> {
    return this.request<T>("get", url, params, config);
  }
```

当然你也可以不对`get`或`post`进行封装，直接使用`request`。

```typescript
export const getAsyncRoutes = (data?: object) => {
  return http.request("get", "/getAsyncRoutes", data);
};
```

### request

```typescript
  public request<T>(
    method: RequestMethods,
    url: string,
    param?: AxiosRequestConfig,
    axiosConfig?: EnclosureHttpRequestConfig
  ): Promise<T> {
    const config = transformConfigByMethod(param, {
      method,
      url,
      ...axiosConfig
    } as EnclosureHttpRequestConfig);
    // 单独处理自定义请求/响应回掉
    return new Promise((resolve, reject) => {
      EnclosureHttp.axiosInstance
        .request(config)
        .then((response: undefined) => {
          resolve(response);
        })
        .catch((error: any) => {
          reject(error);
        });
    });
  }
```

理一下脉络：

- axios 请求接收四个参数：`method`（请求方法）、`url`（baseUrl 后的请求路径）、`param`（携带的参数）、`axiosConfig`（请求配置）
- 参数转换处理：通过`transformConfigByMethod`处理参数，得到最终请求配置`config`
- 使用创建的`axios`实例发送请求，得到响应

正在编写中 ~
