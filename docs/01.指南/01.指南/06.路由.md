---
title: 路由
date: 2021-11-16
permalink: /pages/782b6e/
article: false
---

## 路由配置项

举例列出本项目可能用到的配置选项

```js
const routes = {
  path: "/", // 路径
  name: "test", // 路由名（不要重复）
  component: Layout, // Layout组件，一般不用动
  redirect: "/redirect", // 重定向路径
  meta: {
    title: "测试", // 路由标题（路由在侧边栏和面包屑中展示的名字）
    icon: "icon", // 路由图标
    showLink: true, // 是否在菜单中显示此路由
    i18n: true, // 国际化
    authority: ['admin'], // 路由权限设置
    keepAlive: true // 组件缓存
    rank: 9, // 路由在左侧边栏排列的顺序（数值越低排的越前）
    transition: {
      name: "fade" //当前路由动画效果，参考https://next.router.vuejs.org/guide/advanced/transitions.html#transitions
      enterTransition: "animate__zoomIn", //进入动画 animate.css
      leaveTransition: "animate__zoomOut" //离开动画 animate.css
    },
    // 路由菜单名称右侧的额外图标，支持fontawesome、iconfont、element-plus-icon
    extraIcon: {
      svg: true,
      name: "team-iconxinpinrenqiwang"
    }
  },
  children: [ // 子路由模块
    {
      path: "/error/404",
      name: "404",
      component: () => import("/@/views/error/404.vue"), // 按需加载子组件
      meta: {
        ......
      }
    },
  ]
}
```

## 路由分类

### 静态路由

**constantRoutes：** 不需要动态判断权限的路由，如登录页。（项目中作为开发测试，都作为静态路由）

![image-20211124212903021](https://gitee.com/huohuomua/pictures/raw/master/202111242129053.png)

### 动态路由

**getAsyncRoutes：** 请求后端，动态判断权限返回路由表，并通过 `addRoute` 动态添加的页面。（项目中作为开发测试，动态路由都由`mock`模拟）

先用 Mock 模拟后台，传出`/getAsyncRoutes`接口路由表数据

![image-20211125112204284](https://gitee.com/huohuomua/pictures/raw/master/202111251122326.png)

通过前端封装的 API 接口拿到路由表数据（src/api/routes.ts）

```typescript
import { http } from "../utils/http";

export const getAsyncRoutes = (data?: object) => {
  return http.request("get", "/getAsyncRoutes", data);
};
```

将从后端拿到的路由表进行过滤，生成规范化路由，通过 `router.addRoute` 添加到最终创建的路由实例

```typescript
// 初始化路由
export const initRouter = (name) => {
  return new Promise((resolve) => {
    getAsyncRoutes({ name }).then(({ info }) => {
      if (info.length === 0) {
        usePermissionStoreHook().changeSetting(info);
      } else {
        addAsyncRoutes(info).map((v: any) => {
          // 防止重复添加路由
          if (
            router.options.routes.findIndex(
              (value) => value.path === v.path
            ) !== -1
          ) {
            return;
          } else {
            // 切记将路由push到routes后还需要使用addRoute，这样路由才能正常跳转
            router.options.routes.push(v);
            // 最终路由进行升序
            ascending(router.options.routes);
            router.addRoute(v.name, v);
            usePermissionStoreHook().changeSetting(info);
          }
          resolve(router);
        });
      }
      router.addRoute({
        path: "/:pathMatch(.*)",
        redirect: "/error/404",
      });
    });
  });
};
```

## 路由封装

### 整体思路

![image-20211125115445323](https://gitee.com/huohuomua/pictures/raw/master/202111251154367.png)

### 前置处理

上面我们已经拿到了所有的静态路由表和动态路由表，我们需要将两个表进行整合，并按页面的渲染需要生成最终的路由表。

通过上一小节我们设定好的路由配置项，可以过滤出符合配置的路由表，以适应不同的路由需要。

**路由排序**

```typescript
// 按照路由中 meta 下的 rank 等级升序来排序路由
export const ascending = (arr) => {
  return arr.sort((a: any, b: any) => {
    return a?.meta?.rank - b?.meta?.rank;
  });
};
```

**静态路由导出**

```typescript
// 将所有静态路由导出
export const constantRoutesArr: Array<RouteComponent> = ascending(
  constantRoutes
).concat(...remainingRouter);
```

**路由组件渲染**

```typescript
// 过滤 meta 中 showLink 为 false 的路由
export const filterTree = (data) => {
  const newTree = data.filter((v) => v.meta.showLink);
  newTree.forEach((v) => v.children && (v.children = filterTree(v.children)));
  return newTree;
};
```

**过滤缓存路由**

```typescript
// 从路由中提取 keepAlive 为 true 的 name 组成数组
export const getAliveRoute = () => {
  const alivePageList = [];
  const recursiveSearch = (treeLists) => {
    if (!treeLists || !treeLists.length) {
      return;
    }
    for (let i = 0; i < treeLists.length; i++) {
      if (treeLists[i]?.meta?.keepAlive) alivePageList.push(treeLists[i].name);
      recursiveSearch(treeLists[i].children);
    }
  };
  recursiveSearch(router.options.routes);
  return alivePageList;
};
```

**缓存路由处理（批量删除、增删刷新）**

```typescript
// 批量删除缓存路由
export const delAliveRoutes = (delAliveRouteList: Array<RouteConfigs>) => {
  delAliveRouteList.forEach((route) => {
    usePermissionStoreHook().cacheOperate({
      mode: "delete",
      name: route?.name,
    });
  });
};
```

```typescript
// 处理缓存路由（添加、删除、刷新）
export const handleAliveRoute = (
  matched: RouteRecordNormalized[],
  mode?: string
) => {
  switch (mode) {
    case "add":
      matched.forEach((v) => {
        usePermissionStoreHook().cacheOperate({ mode: "add", name: v.name });
      });
      break;
    case "delete":
      usePermissionStoreHook().cacheOperate({
        mode: "delete",
        name: matched[matched.length - 1].name,
      });
      break;
    default:
      usePermissionStoreHook().cacheOperate({
        mode: "delete",
        name: matched[matched.length - 1].name,
      });
      useTimeoutFn(() => {
        matched.forEach((v) => {
          usePermissionStoreHook().cacheOperate({ mode: "add", name: v.name });
        });
      }, 100);
  }
};
```

### 路由创建

```typescript
// 创建路由实例
export const router: Router = createRouter({
  history: createWebHashHistory(), // 基于 hash 的历史记录（不需要在服务器上进行任何配置，但是 SEO 不友好）
  routes: filterTree(ascending(constantRoutes)).concat(...remainingRouter), // 初始路由表
  scrollBehavior(to, from, savedPosition) {
    // 在页面之间导航时控制滚动的函数，返回的是一个 promise
    return new Promise((resolve) => {
      if (savedPosition) {
        return savedPosition;
      } else {
        if (from.meta.saveSrollTop) {
          const top: number =
            document.documentElement.scrollTop || document.body.scrollTop;
          resolve({ left: 0, top });
        }
      }
    });
  },
});
```

```typescript
// 初始化路由
export const initRouter = (name) => {
  return new Promise((resolve) => {
    getAsyncRoutes({ name }).then(({ info }) => {
      if (info.length === 0) {
        usePermissionStoreHook().changeSetting(info);
      } else {
        addAsyncRoutes(info).map((v: any) => {
          // 防止重复添加路由
          if (
            router.options.routes.findIndex(
              (value) => value.path === v.path
            ) !== -1
          ) {
            return;
          } else {
            router.options.routes.push(v); // 切记将路由push到routes后还需要使用addRoute，这样路由才能正常跳转
            ascending(router.options.routes); // 最终路由进行升序
            router.addRoute(v.name, v);
            usePermissionStoreHook().changeSetting(info);
          }
          resolve(router);
        });
      }
      router.addRoute({
        path: "/:pathMatch(.*)",
        redirect: "/error/404",
      });
    });
  });
};
```

### 导航守卫

```typescript
router.beforeEach((to, _from, next) => {
  if (to.meta?.keepAlive) {
    const newMatched = to.matched;
    handleAliveRoute(newMatched, "add");
    // 页面整体刷新和点击标签页刷新
    if (_from.name === undefined || _from.name === "redirect") {
      handleAliveRoute(newMatched);
    }
  }
  const name = storageSession.getItem("info");
  NProgress.start();
  const externalLink = to?.redirectedFrom?.fullPath;
  if (!externalLink)
    to.matched.some((item) => {
      item.meta.title
        ? (document.title = transformI18n(
            item.meta.title as string,
            item.meta?.i18n as boolean
          ))
        : "";
    });
  if (name) {
    if (_from?.name) {
      // 如果路由包含http 则是超链接 反之是普通路由
      if (externalLink && externalLink.includes("http")) {
        openLink(`http${split(externalLink, "http")[1]}`);
        NProgress.done();
      } else {
        next();
      }
    } else {
      // 刷新
      if (usePermissionStoreHook().wholeRoutes.length === 0)
        initRouter(name.username).then((router: Router) => {
          if (!useMultiTagsStoreHook().getMultiTagsCache) {
            return router.push("/");
          }
          router.push(to.path);
          // 刷新页面更新标签栏与页面路由匹配
          const localRoutes = storageLocal.getItem("responsive-tags");
          const optionsRoutes = router.options?.routes;
          const newLocalRoutes = [];
          optionsRoutes.forEach((ors) => {
            localRoutes.forEach((lrs) => {
              if (ors.path === lrs.parentPath) {
                newLocalRoutes.push(lrs);
              }
            });
          });
          storageLocal.setItem(
            "responsive-tags",
            uniqBy(newLocalRoutes, "path")
          );
        });
      next();
    }
  } else {
    if (to.path !== "/login") {
      if (whiteList.indexOf(to.path) !== -1) {
        next();
      } else {
        next({ path: "/login" });
      }
    } else {
      next();
    }
  }
});
```

### 其他

```typescript
// 重置路由
export function resetRouter() {
  router.getRoutes().forEach((route) => {
    const { name } = route;
    if (name) {
      router.hasRoute(name) && router.removeRoute(name);
    }
  });
}
```

```typescript
// 路由白名单
const whiteList = ["/login"];
```
