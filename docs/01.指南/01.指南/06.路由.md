---
title: 路由
date: 2021-11-16 16:41:12
permalink: /pages/782b6e/
---

## 结构设计

如果你还是这样的路由文件结构，请拍拍屁股赶紧改正过来~

![image-20211124180536198](https://gitee.com/huohuomua/pictures/raw/master/202111241805219.png)

上菜，来看看我们简化的路由文件结构，主要由路由总入口`index.ts`和 路由模块`modules`组成。

![image-20211124175847350](https://gitee.com/huohuomua/pictures/raw/master/202111241758569.png)

这样的结构在大型项目里非常常见，modules 里面的每个文件代表一个路由模块，每个路由模块对应各自相同的功能页面，这样就非常利于项目的维护。

```
├── modules			
│   ├── error.ts                         # 错误页面
│   ├── externalLink.ts                  # 外链页面
│   ├── home.ts                          # 主页面
│   └── remaining.ts                     # 剩余页面（如登录页面、重定向页面）
```

## 路由配置项

举例列出本项目可能用到的配置选项

```js
const routes = {
  path: "/", // 路径
  name: "test", // 路由名（不要重复）
  component: Layout, // 父组件
  redirect: "/redirect", // 重定向路径
  meta: {
    title: "测试", // 路由标题（路由在侧边栏和面包屑中展示的名字）
    icon: "icon", // 路由图标
    showLink: true, // 是否渲染此路由组件
    i18n: true, // 国际化
    rank: 9 // 路由在左侧边栏排列的顺序（数值越低排的越前）
  },
  children: [ // 子路由模块
    {
      path: "/error/404",
      name: "404",
      component: () => import("/@/views/error/404.vue"), // 按需加载子组件
      meta: {
        roles: ['admin'], // 路由权限设置
        keepAlive: true // 组件缓存
        ......
      }
    },
  ]
}
```

这里的配置你可以根据自己的喜好设置配置项（别忘了对配置项进行路由筛选），这里列出花裤衩大佬提供的配置项做学习对比

```js
// 当设置 true 的时候该路由不会在侧边栏出现 如401，login等页面，或者如一些编辑页面/edit/1
hidden: true // (默认 false)

//当设置 noRedirect 的时候该路由在面包屑导航中不可被点击
redirect: 'noRedirect'

// 当你一个路由下面的 children 声明的路由大于1个时，自动会变成嵌套的模式--如组件页面
// 只有一个时，会将那个子路由当做根路由显示在侧边栏--如引导页面
// 若你想不管路由下面的 children 声明的个数都显示你的根路由
// 你可以设置 alwaysShow: true，这样它就会忽略之前定义的规则，一直显示根路由
alwaysShow: true

name: 'router-name' // 设定路由的名字，一定要填写不然使用<keep-alive>时会出现各种问题
meta: {
  roles: ['admin', 'editor'] // 设置该路由进入的权限，支持多个权限叠加
  title: 'title' // 设置该路由在侧边栏和面包屑中展示的名字
  icon: 'svg-name' // 设置该路由的图标，支持 svg-class，也支持 el-icon-x element-ui 的 icon
  noCache: true // 如果设置为true，则不会被 <keep-alive> 缓存(默认 false)
  breadcrumb: false //  如果设置为false，则不会在breadcrumb面包屑中显示(默认 true)
  affix: true // 如果设置为true，它则会固定在tags-view中(默认 false)

  // 当路由设置了该属性，则会高亮相对应的侧边栏。
  // 这在某些场景非常有用，比如：一个文章的列表页路由为：/article/list
  // 点击文章进入文章详情页，这时候路由为/article/1，但你想在侧边栏高亮文章列表的路由，就可以进行如下设置
  activeMenu: '/article/list'
}
```

## 路由分类

### 静态路由

**constantRoutes：** 不需要动态判断权限的路由，如登录页。（项目中作为开发测试，都作为静态路由）

![image-20211124212903021](https://gitee.com/huohuomua/pictures/raw/master/202111242129053.png)

### 动态路由

**getAsyncRoutes：** 请求后端，动态判断权限返回路由表，并通过 `addRoute` 动态添加的页面。（项目中作为开发测试，动态路由都由`mock`模拟）

先用 Mock 模拟后台，传出`/getAsyncRoutes`接口路由表数据

![image-20211125112204284](https://gitee.com/huohuomua/pictures/raw/master/202111251122326.png)

通过前端封装的 API 接口拿到路由表数据（src/api/routes.ts）

```typescript
import { http } from "../utils/http";

export const getAsyncRoutes = (data?: object) => {
  return http.request("get", "/getAsyncRoutes", data);
};
```

将从后端拿到的路由表进行过滤，生成规范化路由，通过 `router.addRoute` 添加到最终创建的路由实例

```typescript
// 初始化路由
export const initRouter = name => {
  return new Promise(resolve => {
    getAsyncRoutes({ name }).then(({ info }) => {
      if (info.length === 0) {
        usePermissionStoreHook().changeSetting(info);
      } else {
        addAsyncRoutes(info).map((v: any) => {
          // 防止重复添加路由
          if (
            router.options.routes.findIndex(value => value.path === v.path) !==
            -1
          ) {
            return;
          } else {
            // 切记将路由push到routes后还需要使用addRoute，这样路由才能正常跳转
            router.options.routes.push(v);
            // 最终路由进行升序
            ascending(router.options.routes);
            router.addRoute(v.name, v);
            usePermissionStoreHook().changeSetting(info);
          }
          resolve(router);
        });
      }
      router.addRoute({
        path: "/:pathMatch(.*)",
        redirect: "/error/404"
      });
    });
  });
};
```



## 路由封装

### 整体思路

![image-20211125115445323](https://gitee.com/huohuomua/pictures/raw/master/202111251154367.png)

### 前置处理

上面我们已经拿到了所有的静态路由表和动态路由表，我们需要将两个表进行整合，并按页面的渲染需要生成最终的路由表。

通过上一小节我们设定好的路由配置项，可以过滤出符合配置的路由表，以适应不同的路由需要。

**路由排序**

```typescript
// 按照路由中 meta 下的 rank 等级升序来排序路由
export const ascending = arr => {
  return arr.sort((a: any, b: any) => {
    return a?.meta?.rank - b?.meta?.rank;
  });
};
```

**静态路由导出**

```typescript
// 将所有静态路由导出
export const constantRoutesArr: Array<RouteComponent> = ascending(
  constantRoutes
).concat(...remainingRouter);
```

**路由组件渲染**

```typescript
// 过滤 meta 中 showLink 为 false 的路由
export const filterTree = data => {
  const newTree = data.filter(v => v.meta.showLink);
  newTree.forEach(v => v.children && (v.children = filterTree(v.children)));
  return newTree;
};
```

**过滤缓存路由**

```typescript
// 从路由中提取 keepAlive 为 true 的 name 组成数组
export const getAliveRoute = () => {
  const alivePageList = [];
  const recursiveSearch = treeLists => {
    if (!treeLists || !treeLists.length) {
      return;
    }
    for (let i = 0; i < treeLists.length; i++) {
      if (treeLists[i]?.meta?.keepAlive) alivePageList.push(treeLists[i].name);
      recursiveSearch(treeLists[i].children);
    }
  };
  recursiveSearch(router.options.routes);
  return alivePageList;
};
```

**缓存路由处理（批量删除、增删刷新）**

```typescript
// 批量删除缓存路由
export const delAliveRoutes = (delAliveRouteList: Array<RouteConfigs>) => {
  delAliveRouteList.forEach(route => {
    usePermissionStoreHook().cacheOperate({
      mode: "delete",
      name: route?.name
    });
  });
};
```

```typescript
// 处理缓存路由（添加、删除、刷新）
export const handleAliveRoute = (
  matched: RouteRecordNormalized[],
  mode?: string
) => {
  switch (mode) {
    case "add":
      matched.forEach(v => {
        usePermissionStoreHook().cacheOperate({ mode: "add", name: v.name });
      });
      break;
    case "delete":
      usePermissionStoreHook().cacheOperate({
        mode: "delete",
        name: matched[matched.length - 1].name
      });
      break;
    default:
      usePermissionStoreHook().cacheOperate({
        mode: "delete",
        name: matched[matched.length - 1].name
      });
      useTimeoutFn(() => {
        matched.forEach(v => {
          usePermissionStoreHook().cacheOperate({ mode: "add", name: v.name });
        });
      }, 100);
  }
};
```

### 路由创建

```typescript
// 创建路由实例
export const router: Router = createRouter({
  history: createWebHashHistory(), // 基于 hash 的历史记录（不需要在服务器上进行任何配置，但是 SEO 不友好）
  routes: filterTree(ascending(constantRoutes)).concat(...remainingRouter), // 初始路由表
  scrollBehavior(to, from, savedPosition) { // 在页面之间导航时控制滚动的函数，返回的是一个 promise
    return new Promise(resolve => {
      if (savedPosition) {
        return savedPosition;
      } else {
        if (from.meta.saveSrollTop) {
          const top: number = document.documentElement.scrollTop || document.body.scrollTop;
          resolve({ left: 0, top });
        }
      }
    });
  }
});
```

```typescript
// 初始化路由
export const initRouter = name => {
  return new Promise(resolve => {
    getAsyncRoutes({ name }).then(({ info }) => {
      if (info.length === 0) {
        usePermissionStoreHook().changeSetting(info);
      } else {
        addAsyncRoutes(info).map((v: any) => {
          // 防止重复添加路由
          if (router.options.routes.findIndex(value => value.path === v.path) !== -1) {
            return;
          } else {
            router.options.routes.push(v);  // 切记将路由push到routes后还需要使用addRoute，这样路由才能正常跳转
            ascending(router.options.routes);  // 最终路由进行升序
            router.addRoute(v.name, v);
            usePermissionStoreHook().changeSetting(info);
          }
          resolve(router);
        });
      }
      router.addRoute({
        path: "/:pathMatch(.*)",
        redirect: "/error/404"
      });
    });
  });
};
```

### 辅助

```typescript
// 重置路由
export function resetRouter() {
  router.getRoutes().forEach(route => {
    const { name } = route;
    if (name) {
      router.hasRoute(name) && router.removeRoute(name);
    }
  });
}
```

```typescript
// 路由白名单
const whiteList = ["/login"];
```

### 导航守卫

```typescript
router.beforeEach((to, _from, next) => {
  if (to.meta?.keepAlive) {
    const newMatched = to.matched;
    handleAliveRoute(newMatched, "add");
    // 页面整体刷新和点击标签页刷新
    if (_from.name === undefined || _from.name === "redirect") {
      handleAliveRoute(newMatched);
    }
  }
  const name = storageSession.getItem("info");
  NProgress.start();
  const externalLink = to?.redirectedFrom?.fullPath;
  if (!externalLink)
    to.matched.some(item => {
      item.meta.title
        ? (document.title = transformI18n(
            item.meta.title as string,
            item.meta?.i18n as boolean
          ))
        : "";
    });
  if (name) {
    if (_from?.name) {
      // 如果路由包含http 则是超链接 反之是普通路由
      if (externalLink && externalLink.includes("http")) {
        openLink(`http${split(externalLink, "http")[1]}`);
        NProgress.done();
      } else {
        next();
      }
    } else {
      // 刷新
      if (usePermissionStoreHook().wholeRoutes.length === 0)
        initRouter(name.username).then((router: Router) => {
          router.push(to.path);
          // 刷新页面更新标签栏与页面路由匹配
          const localRoutes = storageLocal.getItem(
            "responsive-routesInStorage"
          );
          const optionsRoutes = router.options?.routes;
          const newLocalRoutes = [];
          optionsRoutes.forEach(ors => {
            localRoutes.forEach(lrs => {
              if (ors.path === lrs.parentPath) {
                newLocalRoutes.push(lrs);
              }
            });
          });
          storageLocal.setItem(
            "responsive-routesInStorage",
            uniqBy(newLocalRoutes, "path")
          );
        });
      next();
    }
  } else {
    if (to.path !== "/login") {
      if (whiteList.indexOf(to.path) !== -1) {
        next();
      } else {
        next({ path: "/login" });
      }
    } else {
      next();
    }
  }
});

router.afterEach(() => {
  NProgress.done();
});
```

## 其他

### 路由刷新和重定向

### 





